# 이진탐색

> 탐색할 자료를 둘로 나누어, 해당 데이터가 있을 곳을 탐색
> 
- 탐색할 자료가 정렬되어 있을 때만 사용 가능함
- 처리해야 할 데이터의 개수나 값이 1000만 단위 이상이 넘어갈 때 사용

만약 아래와 같이 오름차순이라면

1 - 3 - 9 - 13 - 20 - 23 - 29 - 35

저희가 찾고 싶은 데이터가 35일때

가장 먼저 mid(가운데)를 기준으로 반으로 나누어야합니다.

### left

- 1 - 3 - 9 - 13

### mid

- 20

### right

- 23 - 29 - 35

나누어진 데이터의 35와 mid인 20을 비교합니다.
참고로 가운데를 찾는 방법은 배열 갯수가 홀수, 짝수인 것과 상관 없이, (배열 갯수 / 2) 한 값이 mid의 index가 됩니다.

만약 mid 보다 35가 더 크면 오른쪽에 나누진 데이터를 기준으로 위 작업을 또 반복한다.
(이렇게 때문에 정렬되어 있을 경우에만 사용 가능한 것입니다. 오른쪽엔 mid 보다 큰 값들만 있기 때문입니다.)

만약 mid보다 35가 더 작으면 왼쪽에 나눠진 데이터를 기준으로 반복했을 것이고, mid가 35일 경우, 이땐 원하는 값을 찾은 것이니 true를 리턴합니다.

### left

- 23

### mid

- 29

### right

- 35

이렇게 되면 가운데를 mid로 정하고 왼쪽, 오늘쪽으로 나눈 뒤, mid와 35를 비교합니다.

mid 보다 35가 더 크면 오른쪽에 나눠진 데이터로 위 작업을 반복합니다. 만약 오른쪽에 데이터가 1개만 남았다면 나누는 작업을 더이상 반복하지 않고, 남은 데이터와 탐색하려는 데이터 35를 비교해서, 같다면 ture, 다르면 false를 리턴합니다.

mid를 찾고 반으로 나누는 것을 재귀 함수로 구현하고 탈축 조건은 입력으로 들어온 배열의 데이터가 1개 남았을 때 하면 되겠습니다.

### 코드

```jsx
func binarySearch(_ array: [Int], num: Int) -> Bool {
    if array.count == 1 {
        return array[0] == num ? true : false
    }
    let mid = array.count / 2
    if array[mid] == num { return true }
    let range = array[mid] > num ? (0..<mid) : ((mid + 1)..<array.count)
    
    return binarySearch(Array(array[range]), num: num)
}
 
```

### 조건 정리

1. 배열 내부의 데이터가 정렬되어 있어야합니다.
2. 탐색 범위를 절반씩 좁혀가며 데이터를 탐색
3. 이진 탐색은 위치를 나타내는 변수를 세 개 사용
    1. 시작점, 끝점, 중간점
    2. 중간점으로 찾으려는 데이터와 비교하여 다시 시작점/ 중간점 / 끝점 설정

### 이진 탐색의 시간 복잡도

n개의 배열을 매번 2로 나누어, 최악의 경우 배열의 갯수가 1이 될 때까지 반복하니, 이진 탐색의 시간 복잡도는 **O(log n)** 입니다.