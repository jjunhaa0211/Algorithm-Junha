# 빅오 표기법

### 로그란?

- log_b 라고 한다면 log 아래밑을 나타냅니다.

> 2의 4제곱은 16 == 지수방정식 2^4=16
> 

그러면 2를 몇 제곱해야 16이 나올까?

이것이 로그방정식으로 log_2(16) = 4

그렇다면 로그의 정의는 어떻게 될까요?

> log_b(a) = c    ==    b^c = a
> 

b = 밑

c = 지수

a = 진수

이정도만 알면 될 것 같습니다.

### 빅오 표기법이란?

알고리즘 성능을 수학적으로 표기해주는 표기법으로 **불필요한 연산을 제거하여 알고리즘 분석을 쉽게 할 목적**으로 사용됩니다.

이때 측정되는 복잡성에는 시간 복잡도와 공간 복잡도가 있습니다.

- 시간 복잡도: 입력되는 n의 크기에 따라 실행되는 조작의 수
- 공간 복잡도: 알고리즘이 실행될 때 사용하는 메모리 양
    - (요즘은 메모리가 좋아져서 중요도가 낮아짐)

### 시간 복잡도 표기법

> 알고리즘의 성능을 설명하는 것
> 
- **Big-O(빅 오) 표기법** 알고리즘은 최악의 실행 시간을 표기한다. 최소한 보장되는 성능을 표기하기 때문에 가장 일반적으로 사용한다.
- **Big-Ω(빅 오메가) 표기법** 알고리즘 **최상**의 실행 시간을 표기한다
- **Big-θ(빅 세타) 표기법** 알고리즘 평균 실행 시간을 표기한다

### x 표기법 특징

1. 상수항을 무시
    1. 어떤 알고리즘이 O(N+5)의 복잡도를 가졌으면 상수를 생략해 O(N)으로 표기합니다.
2. 계수도 무시
    1. 어떤 알고리즘이 O(3N)의 복잡도를 가졌으면 계수를 생략해 O(N)으로 표기한다.
3. 최고차항만 표시
    1. 어떤 알고리즘이 O(3N^3+2N^2+N+5)의 복잡도를 가졌으면 O(N^3)으로 표기한다

### 빅오 표기법 종류

실행 속도  `O(1)` < `O(log N)` < `O(N)` < `O(N log N)` < `O(N^2)` < `O(2^N)`

1. O(1)
- 입력값이 증가해도 실행시간은 동일한 알고리즘
    - 입력값의 상관없이 언제나 일정한 알고리즘
- 기본 연산 수라고 생각하면 됩니다.
- push, pop

<br>

2. O(log N)
- 연산이 한 번 실행될 때 마다 데이터의 크기가 절반 감소하는 알고리즘
- binary search 알고리즘, tree 형태 자료구조 탐색

<br>

3. O(N)
- 입력값(N)이 증가함에 따라 실행 시간도 선형적으로 증가하는 알고리즘
    - 입력 데이터의 크기에 비례해서처리 시간이 걸리는 알고리즘
    - n이 1번 늘어날 때마다 처리시간이 1 증가하는 선형적으로 증가
- 데이터와 시간이 같은 비율로 증가
- O(n)일 때는 직선 (1차원)
- 1중 for문

<br>

4. O(N log N)
- O(N)의 알고리즘과 O(log N)의 알고리즘을 중첩된 형태
- 퀵 정렬, 병합 정렬, 힙 정렬

<br>

5. O(N^2)
- O(N)의 알고리즘과 O(log N)의 알고리즘을 중첩된 형태
    - 입력 데이터 n만큼 반복하는데, 그 안에서 n만큼 또 반복할 때의 표기 방법
- 데이터가 적을 때문 문제가 없지만 많아질 수록 수직 상승한다
- O(n^2)일 때는 면적 (2차원)
- 2중 for문, 삽입 정렬, 거품 정렬, 선택 정렬

<br>

6. O(2^n)
- 빅오 표기법 중 가장 느린 시간 복잡도로 주로 재귀적으로 수행하는 알고리즘이 이에 해당합니다.
- fibonacci 수열

<br>

7. O(nm)
- 5번과 비슷하지만, n만큼 2번 반복하는 것이 아니라 n을 m번 반복한다
- n > m 또는 n < m 이런 상황이 발생할 수 있다

<br>

8. O(n^3)
- n을 3중으로 반복한다.
- O(n^3)일 때는 큐빅 (3차원)
- 데이터가 증가할 때마다 더 급격하게 처리시간이 늘어난다.
